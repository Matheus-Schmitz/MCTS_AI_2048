# -*- coding: utf-8 -*-
"""AI_v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13hDqDbCKQLhLxABvEpXgDmZTJrRxb7C0

# Monte-Carlo Tree Search based Artificial Intelligence to play 2048

Matheus Schmitz<br>
<a href="https://www.linkedin.com/in/matheusschmitz/">LinkedIn</a><br>
<a href="https://matheus-schmitz.github.io/">Github Portfolio</a>
"""


"""## Imports"""

import random
import copy
import numpy as np

"""## Board"""

class Board:
    
    def __init__(self):
        self.size = 4
        self.start_tiles = 2
        self.score = 0
        self.victory = False
        self.defeat = False
        self.directions = ['left', 'right', 'up', 'down']
        
        # Initialize the board
        self.board_state = np.zeros((self.size, self.size), dtype=int)
        [self.add_new_tile(value=2) for _ in range(self.start_tiles)]
        
    # Add a value to the board in one of the empty spaces
    def add_new_tile(self, value=None):
        row_num = random.randrange(0, self.size)
        col_num = random.randrange(0, self.size)

        # Pick spots until we find one that is empty
        while not self.board_state[row_num][col_num] == 0:
            row_num = random.randrange(0, self.size)
            col_num = random.randrange(0, self.size)

        # Fill the empty spot with a new value
        if value is None:
            self.board_state[row_num][col_num] = self.generate_random_value()
        else:
            self.board_state[row_num][col_num] = value
        
    # Pick a new value to add to the board
    @staticmethod
    def generate_random_value():
        rand_int = random.randint(1,10)
        value_to_add = 2
        if rand_int > 9:
            value_to_add = 4
        return value_to_add
    
    def merge_left(self):
        initial_board = copy.deepcopy(self)
        
        # On each row push all values left
        for row_idx in range(self.size):
            non_zeros = [x for x in self.board_state[row_idx] if x !=0]
            while len(non_zeros) < 4:
                non_zeros.append(0)
            self.board_state[row_idx] = np.array(non_zeros)
            
        # Merge matching values
        for row_idx in range(self.size):
            for col_idx in range(self.size - 1):
                if self.board_state[row_idx][col_idx] == self.board_state[row_idx][col_idx + 1]:
                    self.board_state[row_idx][col_idx] *= 2
                    self.board_state[row_idx][col_idx + 1] = 0
                    # Update score
                    self.score += self.board_state[row_idx][col_idx]
                    
        # On each row push all values left (need to repeat because of the merges)
        for row_idx in range(self.size):
            non_zeros = [x for x in self.board_state[row_idx] if x !=0]
            while len(non_zeros) < 4:
                non_zeros.append(0)
            self.board_state[row_idx] = np.array(non_zeros)
        
        # If the move did something (changed the board) add a new tile
        if not np.array_equal(self.board_state, initial_board.board_state):
            self.add_new_tile()

    def reverse_rows(self):
        self.board_state = self.board_state[:,::-1]
        
    def transpose_board(self):
        self.board_state = self.board_state.transpose()
    
    def merge_right(self):
        self.reverse_rows()
        self.merge_left()
        self.reverse_rows()
        
    def merge_up(self):
        self.transpose_board()
        self.merge_left()
        self.transpose_board()
        
    def merge_down(self):
        self.transpose_board()
        self.merge_right()
        self.transpose_board()
        
    def check_victory(self):
        if 2048 in self.board_state:
            self.victory = True
    
    def has_moves(self):
        # Can move left?
        initial_board = copy.deepcopy(self)
        initial_board.merge_left()
        if not np.array_equal(self.board_state, initial_board.board_state):
            return True
        
        # Can move right?
        initial_board = copy.deepcopy(self)
        initial_board.merge_right()
        if not np.array_equal(self.board_state, initial_board.board_state):
            return True

        # Can move up?
        initial_board = copy.deepcopy(self)
        initial_board.merge_up()
        if not np.array_equal(self.board_state, initial_board.board_state):
            return True
        
        # Can move down?
        initial_board = copy.deepcopy(self)
        initial_board.merge_down()
        if not np.array_equal(self.board_state, initial_board.board_state):
            return True
        
        return False
    
    def check_defeat(self):
        if not self.has_moves():
            self.defeat = True
    
    def winner_screen(self):
        print("###########")
        print("  YOU WON  ")
        print("###########")
        print()
        print(f"Final Score: {self.score} | Max Tile: {self.board_state.max()}")
        print()
        print(self.board_state)
        print()
        
    def loser_screen(self):
        print("############")
        print("  YOU LOST ")
        print("############")
        print()
        print(f"Final Score: {self.score} | Max Tile: {self.board_state.max()}")
        print()
        print(self.board_state)  
        print()

"""## Game"""

class Game:
    
    def __init__(self):
        self.board = Board()
    
    def move(self, direction, update_status=True):
        # Make designated move
        if direction == 'left':
            self.board.merge_left()
            
        elif direction == 'right':
            self.board.merge_right()
            
        elif direction == 'up':
            self.board.merge_up()
            
        elif direction == 'down':
            self.board.merge_down()

        else:
            print("Invalid move. Choose ['left', 'right', 'up', 'down']")
            print()
           
        
        self.board.check_victory()
        self.board.check_defeat()
        
        if update_status:
            print(f"Current Score: {self.board.score} | Max Tile: {self.board.board_state.max()}")
            print(self.board.board_state)
            print()
                
            # Check for end of game  
            if self.board.victory:
                self.board.winner_screen()
            elif self.board.defeat:
                self.board.loser_screen()
            
    def play_randomly(self):
        while True:
            direction = random.choice(self.board.directions)
            self.move(direction, update_status=False)
            #if self.board.victory or self.board.defeat:
            if self.board.defeat:    
                return self.board.score

"""## Monte Carlo Tree Search"""

def monte_carlo_tree_search(game, num_iterations):
    overall_scores = list()
    for direction in game.board.directions:
        direction_score = 0
        for _ in range(num_iterations):
            simulation = copy.deepcopy(game)
            simulation.move(direction, update_status=False)
            simulation_score = simulation.play_randomly()
            direction_score += simulation_score
        overall_scores.append(direction_score)
    return overall_scores

"""## Generate Training Data for NN"""

import glob
import pandas as pd
import os

# x = (1, 4, 4, 11)
# y = win probability = range of [0,1] for victory or [0,-1] for loss 
# y = expected end-game score
# later moves matter more, so might want to take y^e or such (make sure to keep the sign)

# Ensure storage directory exists
if not os.path.exists('./simulated_games'):
    os.makedirs('./simulated_games')

# Generate training data ad-infinitum
while True:
    
    # Initialize a game and define its number
    game = Game()

    # DataFrame to store all game steps
    df = pd.DataFrame()

    # Play the game with Monte Carlo Tree Search
    while True:
        
        # Choose and execute the next move
        move_scores = monte_carlo_tree_search(game, 25)
        next_move_idx = np.argmax(move_scores)
        next_move = game.board.directions[next_move_idx]
        game.move(next_move, update_status=False)

        # Save current board state
        current_state = game.board.board_state.flatten().tolist()
        current_state.append(game.board.score)
        df = df.append([current_state])

        # Check for end of game  
        #if game.board.victory:
        #    # Linear probability increase with each step [0,1] for victory
        #    probas = np.linspace(start=10e-6, stop=1, num=df.shape[0])
        #    df['probas'] = probas

        #    # Save game history
        #    df.to_csv(f"simulated_games/game_{game_number}.csv", index=False)
        #    game_number += 1

        #    # Print game-over screen
        #    game.board.winner_screen()
        #    break

        if game.board.defeat:
            # Linear probability increase with each step [0,-1] for defeat
            #probas = np.linspace(start=10e-6, stop=-1, num=df.shape[0])
            #df['probas'] = probas
            #df['score'] = game.board.score

            # Save game history
            game_number = len(glob.glob("./simulated_games/*.csv"))+1
            df.to_csv(f"simulated_games/game_{game_number}.csv", index=False)
            
            # Print game-over screen
            game.board.loser_screen()
            break

